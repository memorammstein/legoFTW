#pragma config(Sensor, S1,     touchSensor,    sensorTouch)
#pragma config(Sensor, S2,     sonarSensor,    sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define LEFT 1
#define RIGHT 2
#define turnTime 550
#define somethingClose 40
#define highSpeed -80
#define noSpeed 0
#define reverseSpeed 80

void turnLeft()
{
	motor[motorC] = noSpeed;
	motor[motorB] = reverseSpeed;
	wait1Msec(turnTime);
	motor[motorB] = noSpeed;
}

void turnRight()
{
	motor[motorB] = noSpeed;
	motor[motorC] = reverseSpeed;
	wait1Msec(turnTime);
	motor[motorC] = noSpeed;
}

task main()
{
	// wait 50 msec to initialize light sensor
	wait1Msec(50);

	int wallIs = 0;

	while(true)
	{
		// run ahead to slam against something
		motor[motorB] = highSpeed;
		motor[motorC] = highSpeed;
		while(SensorValue[touchSensor] == 0){};

		// Left
		motor[motorB] = noSpeed;
		motor[motorC] = noSpeed;
		wait1Msec(100);

		// turn
		turnRight();
		if(SensorValue[sonarSensor] < somethingClose)
		{
			wallIs = RIGHT;
		} else
		{
			turnLeft();
			turnLeft();
			wallIs = LEFT;
		}
		if(wallIs == RIGHT)
		{
				// ahead full while the obstacle is near
				motor[motorB] = highSpeed;
				motor[motorC] = highSpeed;
				while (SensorValue[sonarSensor] < somethingClose){};
				wait1Msec(250);

				// when the obstacle is cleared, turn
				motor[motorB] = noSpeed;
				wait1Msec(turnTime);

				// when the turn ends, continue
				motor[motorB] = highSpeed;
		} else
		{
				motor[motorB] = highSpeed;
				motor[motorC] = highSpeed;
				wait1Msec(100);
				motor[motorB] = noSpeed;
				motor[motorC] = noSpeed;
				turnRight();
				motor[motorB] = highSpeed;
				motor[motorC] = highSpeed;
				while(SensorValue[touchSensor] == 0){};
				motor[motorB] = noSpeed;
				motor[motorC] = noSpeed;
				turnLeft();
		}
	}
}
